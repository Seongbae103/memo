## 소스 / 리소스
- 가공 전인 리소스를 가공 후인 소스로 바꿔주는 텍스트 파일이 소스코드
- src 내부의 파일은 소스(여기가 우리의 본진)
- 나머지는 리소스
---
## 도구, 시스템, 서버
- IDE(개발환경) : 도구+언어 
- 도구(또는 시스템) → 개발 환경을 구축하는 시스템, 언어에 의존해서 시스템을 개발(배포 후에는 사라진다)<br/>
- 서버 → 클라이언트의 요청에 의해 서비스를 제공하는 시스템. 즉, 서버와 클라이언트는 상황에 따라 달라진다<br/>
- 시스템 → 개발 환경을 통해 구축한 서버와 클라이언트 → 결국 서버와 클라이언트의 본질<br/>

    > 서버인지 클라이언트인지는 결국 역할에 따라 달라진다

> 프로젝트를 진행한다 = 도구와 언어를 이용해 시스템을 만드는 것<br/>

- request와 response는 본질은 같지만 방향만 다르다 (동시에 한 공간에 있을 수 없다)

---
## 관계
#### is a
> 상관 관계
#### has a
##### 연관 관계(생명 주기가 동일)
    > 상속 등
##### 의존 관계(생명 주기가 다르다)

---
## 단방향 / 양방향
<a href="https://jeong-pro.tistory.com/231"> 참고 </a>
- 개념을 잊어서 사고치지말자
- 프론트에서 단방향은 절대 자식에서 부모로 올라갈 수 없다

---
## 라이브러리와 프레임워크의 차이
- 라이브러리와 프레임워크 간에 포함관계는 없다
- 장고, 플라스크는 시작부터 프레임워크, 리액트는 둘 다 가능
- 라이브러리
  - 모듈과 패키지의 집합
    - 패키지(컴파일언어) - (인터프리터 언어는 디렉토리 사용-> 프로젝트는 디렉토리를 사용)
      - 모듈들을 하나의 상위 폴더에 있다
      - 패키지 안에 여러가지 폴더가 있을 수 있다
    - 모듈 : 재사용이 가능한 클래스의 집합
- 프레임워크
  - 작업의 구조가 정해진 라이브러리 → 제어흐름을 갖는 시스템
  특정 문제 해결을 위해 상호 협력하는 클래스와 인터페이스의 집합으로 프로그래머의 작업이 필요
> 차이점
> - 코드의 <a style=color:rgb(178,102,255)>제어 흐름</a>
>   - 흐름이 사용자에게 있으면 라이브러리, 시스템에게 있으면 프레임워크
>   - 라이브러리는 사용자가 객체나 함수를 <a style=color:red>직접 호출</a>
>   - 프레임워크는 프레임워크에 의해 메서드가 호출<p>
>>  제어흐름 : 프로그램에서 실행되는 함수가 <a style=color:rgb(178,102,255)> 호출되는 순서</a>

> 프레임워크는 충분조건, 라이브러리는 필요조건(1:1이면 필요충분조건)

> 둘의 구분은 개발자의 손을 탔는지가 아니라 

명칭 그대로 도서관에서 필요한 파일(패키지)과 문서(모듈)를 꺼내서 다른 곳에 옮겨적는 것처럼 사용자에게 제어 흐름이 있고
프레임워크는 건축의 뼈대처럼 정해진 틀 안에서 작업을 수행해야하기 때문에 프레임워크에게 제어 흐름이 있다?

## prefix(접두사) / postfix

## 인조키
- 시퀀스
- uuid

---
## 이미지 / 컨테이너
- 이미지 : 특정 프로세스를 실행하기 위한 모든 파일과 속성값 
## 상태(state)값과 설정(context)값(-it)
- 상태 : 변하냐 변하지 않냐의 차이
  - 변하는 상태는 상태값, 변하지 않는 상태는 설정값
  - 파라미터와 아규먼트는 각각 설정값과 상태값 중 뭘 가지나?
- 파이썬 입장에서 이미지는 class, 컨테이너는 인스턴스, 도커는 파일, 디렉토리는 설정값, 패키지는 상태값
- 설정값 오류가 났을 때는 rm 후 도커파일의 설정값을 다시 설정한다. 
- 메인영역의 메타데이터는 변경이 없지만 서브 영역은 상태가 변한다
> ※ 설정값은 상수가 아님을 기억해라
---
## 컴포넌트와 컨테이너
- 컴포넌트 : 재사용이 가능한 객체
- 컨테이너 : 여러 컴포넌트를 담는 객체
---

## Atomic Pattern
- Atom → Molecule → Organism → Template → Page
    > 기본적으로 하위 개념은 상위 개념의 컴포넌트고 상위 개념은 하위 개념의 컨테이너
    >> 여기서는 원자, 분자, 유기체를 컴포넌트, 템플릿을 컨테이너로
    
#### Atom
- 가장 작은 단위의 컴포넌트
- 어떤 설정값이 주어져도 생성되어야해서 다양한 상태값을 가지고 있어야한다
- 마진이나 위치값을 가지지 않는다
 
---
## work, job, task

---
## MSA
## EDA(이벤트 드리븐 아키텍처)
> 이벤트 주도 : 체인 메소드

## 이벤트 버블링 캡쳐링
> 버블링 : 자식에서 부모로 이벤트가 전딜
> 캡쳐링 : 부모에서 자식으로 이벤트가 전달
<a href="https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/"></a>
- 람다로 하면
  
  
    const onClick = e=>{}

- 에러시 consol.lig로 버블이 끊긴 부분을 해결해야한다
<a style="color:p">버블링과 캡쳐링은 느리다 스토어에 집어넣는 디스패치를 이용해서 사용</a>

#### <a style="color:red">한 컨테이너에 양, 단방향을 둘 다 넣지마라</a>

---

## 크로스 플랫폼(브릿지패턴)
## 덕 타이핑(덕 패턴)
> 객체의 타입이 아닌 메소드의 역할에 의해 객체의 역할이 주어지는 형태
> 객체(클래스) 기반이 아니라 함수지향 - 함수를 통해
#### 기존의 리덕스
- action, store(actiontypes), reducer를 필요조건으로 가진다(세 개 동시면 충분조건)
#### 덕 타이핑을 하면
- components, container, store로 돼있던(12-05) 모듈들을 각 컨텐츠인 todos, counter등으로 나눈다(12-06)

---
## stateful/ stateless

---
# Router (ERD의 Cross Entity와 같은 개념)

데이터프레임  csv 

on_delete 부모가 지워지면 같이
CASCADE

바닐라js
리액트 : 바닐라js에 라이브러리를 올린 것

## 클라이언트 서버

## json
1. json의 구조 
   - 파이썬 딕셔너리({})나 리스트([], json에서는 array)구조와 동일하다
- 

## 서버
#### 서버 객체 생성
    listen(port, [hostname], [backlog], [callback])

---
- 방법
  - 생성자 a=A()구조
  - 팩토리 pd.~구조

- a = b에서 값인 b가 설정값과 상태값이다  
  - 상태값 : 불규칙하고 바뀐다
  - 설정값(context) : 맥락이 있다 
  - 전역에 들어가면 거의 설정값, 지역은 상태를 갖는다
  

---|클라이언트 서버 | 웹서버 | was | db 서버
---|---|---|---|---
언어|리액트|---|---|sql


### CORS
- sgi.py는 공유기 같은 역할 백에서 받은 내용을 프론트로 보내주는 역할
- 크로스 관계는 두 객체가 서로 만나지 않고 기능을 공유한다.
---
tip?
과정이 필요한 이유를 이해해야지 그냥 외우는 공부는 x

## JavaScript 
- ES(ECMAScript)6이상을 공부해야 인공지능에 사용 가능
- 스크립트 -> 인터프리트 언어(컴파일 후 실행되는 컴파일과 달리 인터프리터는 바로 실행되기 때문에 더 어렵다)

## React
- SPA(single-page application)나 모바일 애플리케이션 개발에 사용 가능
- 규모가 커지면 라우팅(WSGI), API통신 등이 요구
- 라우팅과 API통신은 크로스(ERD의 크로스 엔티티와 같은 개념)
## 
인공지능 베이스에서는 뷰보다 리액트
안드로이드에서는 뷰가 더 좋다


---

## SPA(Single Page Application)와 MPA(Multiple Page Application)
- MPA였을 때는 페이지 별로 코딩을 했지만 SPA를 사용하면 메모리 절약으로 인한 속도 향상이 가능
  - 페이지 요청시마다 정적 리소스를 다운로드는 MPA와 달리 SPA는 모든 정적 리소스를 최초 한 번에 다운로드한다
- 이미 정해진 코딩이 있는 MPA방식은 사용자에 따라 달라져야하는 인공지능에 부적합하고 속도도 느려서 SPA를 사용

## 파이썬 구조분산 할당

# SPA
> 메모리 상에는 하나의 페이지만 존재한다(html은 여러개여도 된다)

# pub sub 패턴
- event data store 부분이 우리가 코딩하는 부분

##### store의 의미
- pub-sub에서 event data store
- 화면처리에서는 컨테이너를 사용하고 스토어에는 데이터만 존재하도록 나눈다 
- 상태 전부가 담기는 충분조건

상대적인 개념이지만 설정의 위치에 있는 것들은 const(함수)로 나온다

#### <div style=color:red>★★★★★ 이제 동기식이 아니라 비동기식으로 개발해야한다<p/>

---
## 맵 필터 리듀스

--- 
## Redux
- 예측 가능한(=충분조건) 상태 컨테이너
  - = 충분조건이 만족되면 자동으로 작동하는 컨테이너
- 스칼라(단일값)으로 
---
#### 리액트 생태계는 프레임워크지만 리액트 안은 라이브러리

##### 필요 충분 조건
- 필요조건 : 반드시 필요한 조건(val)
- 충분조건 : 만족되면 진술이 참인 조건(var)
> var = val

## 상태와 상태값
- 상태 : 컨테이너 내부의 빈 공간
- 상태값 : 
- 차이 : 
<a href ="https://zdnet.co.kr/view/?no=20221202183934">이벤트 드리븐</a>
## axios
> react와 django를 연동할 때 사용
## 이미지 처리

---
12-06
## MSA
> 비동기식 연습
> 
## {...input, [name] : value }의 의미
<img src="C:\Users\AIA\Downloads\5.png">
dispatch:외부에서 입력받은 객체인 action을 store로 보내주는 역할
store:view인 쟝고로 보낸다
- dispatch에 담기면 store에 담기기 전에 빠져나갈 수 없다

dispatch(addTodo({text:value}))에서
함수 부분인 addTodo({text:value})가 action이다
 
const todoSlice = createSlice({
  name: 'todos',
  initialState: [],

---
장고 연결
---

## 데이터
- Data (info와의 차이는 )
- DB : 데이터 저장소 (스토리지와의 차이는 디스크/메모리)
- DB Tool
- DBMS
- DB Server
- DB Center
- Data Warehouse
- Data Set

batch : 샘플을 자른 것

## Ground Truth
> 실제값